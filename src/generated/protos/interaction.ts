// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: interaction.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Empty as Empty1 } from "./google/protobuf/empty";
import { StringValue } from "./google/protobuf/wrappers";

export const protobufPackage = "rox.interaction";

/**
 * Optional: Service the frontend could implement (called by agent for updates)
 * service ClientNotification {
 *   rpc NotifyClient(AgentUpdate) returns (Empty);
 * }
 * message AgentUpdate {
 *   string update_type = 1;
 *   string content = 2;
 * }
 * Enum to define what kind of UI action the agent wants the client to perform
 */
export enum ClientUIActionType {
  NO_ACTION = 0,
  SHOW_ALERT = 1,
  UPDATE_TEXT_CONTENT = 2,
  TOGGLE_ELEMENT_VISIBILITY = 3,
  START_TIMER = 4,
  STOP_TIMER = 5,
  PAUSE_TIMER = 6,
  RESET_TIMER = 7,
  UPDATE_PROGRESS_INDICATOR = 8,
  UPDATE_SCORE_OR_PROGRESS = 9,
  /** SHOW_ELEMENT - UI Control & State Actions */
  SHOW_ELEMENT = 10,
  HIDE_ELEMENT = 11,
  /** NAVIGATE_TO_PAGE - Navigation Actions */
  NAVIGATE_TO_PAGE = 12,
  /** UPDATE_LIVE_TRANSCRIPT - Content Display Actions */
  UPDATE_LIVE_TRANSCRIPT = 13,
  DISPLAY_TRANSCRIPT_OR_TEXT = 14,
  DISPLAY_REMARKS_LIST = 15,
  /** SET_BUTTON_PROPERTIES - Button & Input Actions */
  SET_BUTTON_PROPERTIES = 21,
  ENABLE_BUTTON = 22,
  DISABLE_BUTTON = 23,
  SHOW_BUTTON_OPTIONS = 24,
  CLEAR_INPUT_FIELD = 25,
  /** SET_EDITOR_READONLY_SECTIONS - Editor & Content Actions */
  SET_EDITOR_READONLY_SECTIONS = 26,
  /** SHOW_LOADING_INDICATOR - Feedback & Loading Actions */
  SHOW_LOADING_INDICATOR = 27,
  /** HIGHLIGHT_TEXT_RANGES - Add more actions here as needed */
  HIGHLIGHT_TEXT_RANGES = 28,
  /** SUGGEST_TEXT_EDIT - Action to suggest a text edit */
  SUGGEST_TEXT_EDIT = 29,
  /** SHOW_INLINE_SUGGESTION - Action to show a non-intrusive inline suggestion */
  SHOW_INLINE_SUGGESTION = 30,
  /** SHOW_TOOLTIP_OR_COMMENT - Action to display a tooltip or comment */
  SHOW_TOOLTIP_OR_COMMENT = 31,
  /** SET_EDITOR_CONTENT - Action to set the entire content of an editor */
  SET_EDITOR_CONTENT = 32,
  /** APPEND_TEXT_TO_EDITOR_REALTIME - Action to append text chunks to an editor */
  APPEND_TEXT_TO_EDITOR_REALTIME = 33,
  /** STRIKETHROUGH_TEXT_RANGES - Action to strikethrough text ranges */
  STRIKETHROUGH_TEXT_RANGES = 34,
  /** START_LISTENING - Conversational Actions */
  START_LISTENING = 35,
  /** STOP_LISTENING - Action to make the client stop listening */
  STOP_LISTENING = 36,
  /** EXECUTE_CONVERSATIONAL_SEQUENCE - Action to execute a conversational sequence */
  EXECUTE_CONVERSATIONAL_SEQUENCE = 37,
  /** PROMPT_FOR_USER_INPUT - Action to prompt the user for input */
  PROMPT_FOR_USER_INPUT = 38,
  /** START_LISTENING_VISUAL - --- ADD THESE NEW ACTIONS --- */
  START_LISTENING_VISUAL = 39,
  STOP_LISTENING_VISUAL = 40,
  SET_UI_STATE = 41,
  /** DISPLAY_VISUAL_AID - Add more actions here, e.g., CLICK_BUTTON, CHANGE_IMAGE_SRC */
  DISPLAY_VISUAL_AID = 42,
  /** FETCH_AND_DISPLAY_COURSE_MAP - Action to fetch and display course map data */
  FETCH_AND_DISPLAY_COURSE_MAP = 43,
  /** END_DOUBT_LISTENING_SESSION - Action to end a doubt listening session */
  END_DOUBT_LISTENING_SESSION = 44,
  /** START_DOUBT_LISTENING_SESSION - Action to start a doubt listening session */
  START_DOUBT_LISTENING_SESSION = 45,
  /** REPLACE_TEXT_RANGE - Action to replace a range of text */
  REPLACE_TEXT_RANGE = 46,
  SHOW_FEEDBACK = 47,
  HIGHLIGHT_ELEMENT = 48,
  /** GENERATE_VISUALIZATION - NEW FRONTEND VOCABULARY ACTIONS (for advanced interactive capabilities) */
  GENERATE_VISUALIZATION = 49,
  /** HIGHLIGHT_ELEMENTS - Highlight multiple UI elements (plural) */
  HIGHLIGHT_ELEMENTS = 50,
  /** GIVE_STUDENT_CONTROL - Transfer control to student with message */
  GIVE_STUDENT_CONTROL = 51,
  /** TAKE_AI_CONTROL - AI regains control with message */
  TAKE_AI_CONTROL = 52,
  /** CLEAR_ALL_ANNOTATIONS - Clear all visual annotations and highlights */
  CLEAR_ALL_ANNOTATIONS = 53,
  /** JUPYTER_TYPE_IN_CELL - Jupyter Notebook Actions */
  JUPYTER_TYPE_IN_CELL = 54,
  /** JUPYTER_RUN_CELL - Execute a Jupyter notebook cell */
  JUPYTER_RUN_CELL = 55,
  /** JUPYTER_CREATE_NEW_CELL - Create a new Jupyter notebook cell */
  JUPYTER_CREATE_NEW_CELL = 56,
  /** JUPYTER_SCROLL_TO_CELL - Scroll to a specific cell in Jupyter notebook */
  JUPYTER_SCROLL_TO_CELL = 57,
  /** JUPYTER_CLICK_PYODIDE - Click on a Pyodide element in Jupyter notebook */
  JUPYTER_CLICK_PYODIDE = 58,
  /** BROWSER_NAVIGATE - Browser Navigation and Interaction Actions */
  BROWSER_NAVIGATE = 59,
  /** BROWSER_CLICK - Click on a browser element */
  BROWSER_CLICK = 60,
  /** BROWSER_TYPE - Type text into a browser input field */
  BROWSER_TYPE = 61,
  /** UPLOAD_FILE_TO_JUPYTER - Upload a file to Jupyter notebook environment */
  UPLOAD_FILE_TO_JUPYTER = 62,
  HIGHLIGHT_CELL_FOR_DOUBT_RESOLUTION = 63,
  UNRECOGNIZED = -1,
}

export function clientUIActionTypeFromJSON(object: any): ClientUIActionType {
  switch (object) {
    case 0:
    case "NO_ACTION":
      return ClientUIActionType.NO_ACTION;
    case 1:
    case "SHOW_ALERT":
      return ClientUIActionType.SHOW_ALERT;
    case 2:
    case "UPDATE_TEXT_CONTENT":
      return ClientUIActionType.UPDATE_TEXT_CONTENT;
    case 3:
    case "TOGGLE_ELEMENT_VISIBILITY":
      return ClientUIActionType.TOGGLE_ELEMENT_VISIBILITY;
    case 4:
    case "START_TIMER":
      return ClientUIActionType.START_TIMER;
    case 5:
    case "STOP_TIMER":
      return ClientUIActionType.STOP_TIMER;
    case 6:
    case "PAUSE_TIMER":
      return ClientUIActionType.PAUSE_TIMER;
    case 7:
    case "RESET_TIMER":
      return ClientUIActionType.RESET_TIMER;
    case 8:
    case "UPDATE_PROGRESS_INDICATOR":
      return ClientUIActionType.UPDATE_PROGRESS_INDICATOR;
    case 9:
    case "UPDATE_SCORE_OR_PROGRESS":
      return ClientUIActionType.UPDATE_SCORE_OR_PROGRESS;
    case 10:
    case "SHOW_ELEMENT":
      return ClientUIActionType.SHOW_ELEMENT;
    case 11:
    case "HIDE_ELEMENT":
      return ClientUIActionType.HIDE_ELEMENT;
    case 12:
    case "NAVIGATE_TO_PAGE":
      return ClientUIActionType.NAVIGATE_TO_PAGE;
    case 13:
    case "UPDATE_LIVE_TRANSCRIPT":
      return ClientUIActionType.UPDATE_LIVE_TRANSCRIPT;
    case 14:
    case "DISPLAY_TRANSCRIPT_OR_TEXT":
      return ClientUIActionType.DISPLAY_TRANSCRIPT_OR_TEXT;
    case 15:
    case "DISPLAY_REMARKS_LIST":
      return ClientUIActionType.DISPLAY_REMARKS_LIST;
    case 21:
    case "SET_BUTTON_PROPERTIES":
      return ClientUIActionType.SET_BUTTON_PROPERTIES;
    case 22:
    case "ENABLE_BUTTON":
      return ClientUIActionType.ENABLE_BUTTON;
    case 23:
    case "DISABLE_BUTTON":
      return ClientUIActionType.DISABLE_BUTTON;
    case 24:
    case "SHOW_BUTTON_OPTIONS":
      return ClientUIActionType.SHOW_BUTTON_OPTIONS;
    case 25:
    case "CLEAR_INPUT_FIELD":
      return ClientUIActionType.CLEAR_INPUT_FIELD;
    case 26:
    case "SET_EDITOR_READONLY_SECTIONS":
      return ClientUIActionType.SET_EDITOR_READONLY_SECTIONS;
    case 27:
    case "SHOW_LOADING_INDICATOR":
      return ClientUIActionType.SHOW_LOADING_INDICATOR;
    case 28:
    case "HIGHLIGHT_TEXT_RANGES":
      return ClientUIActionType.HIGHLIGHT_TEXT_RANGES;
    case 29:
    case "SUGGEST_TEXT_EDIT":
      return ClientUIActionType.SUGGEST_TEXT_EDIT;
    case 30:
    case "SHOW_INLINE_SUGGESTION":
      return ClientUIActionType.SHOW_INLINE_SUGGESTION;
    case 31:
    case "SHOW_TOOLTIP_OR_COMMENT":
      return ClientUIActionType.SHOW_TOOLTIP_OR_COMMENT;
    case 32:
    case "SET_EDITOR_CONTENT":
      return ClientUIActionType.SET_EDITOR_CONTENT;
    case 33:
    case "APPEND_TEXT_TO_EDITOR_REALTIME":
      return ClientUIActionType.APPEND_TEXT_TO_EDITOR_REALTIME;
    case 34:
    case "STRIKETHROUGH_TEXT_RANGES":
      return ClientUIActionType.STRIKETHROUGH_TEXT_RANGES;
    case 35:
    case "START_LISTENING":
      return ClientUIActionType.START_LISTENING;
    case 36:
    case "STOP_LISTENING":
      return ClientUIActionType.STOP_LISTENING;
    case 37:
    case "EXECUTE_CONVERSATIONAL_SEQUENCE":
      return ClientUIActionType.EXECUTE_CONVERSATIONAL_SEQUENCE;
    case 38:
    case "PROMPT_FOR_USER_INPUT":
      return ClientUIActionType.PROMPT_FOR_USER_INPUT;
    case 39:
    case "START_LISTENING_VISUAL":
      return ClientUIActionType.START_LISTENING_VISUAL;
    case 40:
    case "STOP_LISTENING_VISUAL":
      return ClientUIActionType.STOP_LISTENING_VISUAL;
    case 41:
    case "SET_UI_STATE":
      return ClientUIActionType.SET_UI_STATE;
    case 42:
    case "DISPLAY_VISUAL_AID":
      return ClientUIActionType.DISPLAY_VISUAL_AID;
    case 43:
    case "FETCH_AND_DISPLAY_COURSE_MAP":
      return ClientUIActionType.FETCH_AND_DISPLAY_COURSE_MAP;
    case 44:
    case "END_DOUBT_LISTENING_SESSION":
      return ClientUIActionType.END_DOUBT_LISTENING_SESSION;
    case 45:
    case "START_DOUBT_LISTENING_SESSION":
      return ClientUIActionType.START_DOUBT_LISTENING_SESSION;
    case 46:
    case "REPLACE_TEXT_RANGE":
      return ClientUIActionType.REPLACE_TEXT_RANGE;
    case 47:
    case "SHOW_FEEDBACK":
      return ClientUIActionType.SHOW_FEEDBACK;
    case 48:
    case "HIGHLIGHT_ELEMENT":
      return ClientUIActionType.HIGHLIGHT_ELEMENT;
    case 49:
    case "GENERATE_VISUALIZATION":
      return ClientUIActionType.GENERATE_VISUALIZATION;
    case 50:
    case "HIGHLIGHT_ELEMENTS":
      return ClientUIActionType.HIGHLIGHT_ELEMENTS;
    case 51:
    case "GIVE_STUDENT_CONTROL":
      return ClientUIActionType.GIVE_STUDENT_CONTROL;
    case 52:
    case "TAKE_AI_CONTROL":
      return ClientUIActionType.TAKE_AI_CONTROL;
    case 53:
    case "CLEAR_ALL_ANNOTATIONS":
      return ClientUIActionType.CLEAR_ALL_ANNOTATIONS;
    case 54:
    case "JUPYTER_TYPE_IN_CELL":
      return ClientUIActionType.JUPYTER_TYPE_IN_CELL;
    case 55:
    case "JUPYTER_RUN_CELL":
      return ClientUIActionType.JUPYTER_RUN_CELL;
    case 56:
    case "JUPYTER_CREATE_NEW_CELL":
      return ClientUIActionType.JUPYTER_CREATE_NEW_CELL;
    case 57:
    case "JUPYTER_SCROLL_TO_CELL":
      return ClientUIActionType.JUPYTER_SCROLL_TO_CELL;
    case 58:
    case "JUPYTER_CLICK_PYODIDE":
      return ClientUIActionType.JUPYTER_CLICK_PYODIDE;
    case 59:
    case "BROWSER_NAVIGATE":
      return ClientUIActionType.BROWSER_NAVIGATE;
    case 60:
    case "BROWSER_CLICK":
      return ClientUIActionType.BROWSER_CLICK;
    case 61:
    case "BROWSER_TYPE":
      return ClientUIActionType.BROWSER_TYPE;
    case 62:
    case "UPLOAD_FILE_TO_JUPYTER":
      return ClientUIActionType.UPLOAD_FILE_TO_JUPYTER;
    case 63:
    case "HIGHLIGHT_CELL_FOR_DOUBT_RESOLUTION":
      return ClientUIActionType.HIGHLIGHT_CELL_FOR_DOUBT_RESOLUTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ClientUIActionType.UNRECOGNIZED;
  }
}

export function clientUIActionTypeToJSON(object: ClientUIActionType): string {
  switch (object) {
    case ClientUIActionType.NO_ACTION:
      return "NO_ACTION";
    case ClientUIActionType.SHOW_ALERT:
      return "SHOW_ALERT";
    case ClientUIActionType.UPDATE_TEXT_CONTENT:
      return "UPDATE_TEXT_CONTENT";
    case ClientUIActionType.TOGGLE_ELEMENT_VISIBILITY:
      return "TOGGLE_ELEMENT_VISIBILITY";
    case ClientUIActionType.START_TIMER:
      return "START_TIMER";
    case ClientUIActionType.STOP_TIMER:
      return "STOP_TIMER";
    case ClientUIActionType.PAUSE_TIMER:
      return "PAUSE_TIMER";
    case ClientUIActionType.RESET_TIMER:
      return "RESET_TIMER";
    case ClientUIActionType.UPDATE_PROGRESS_INDICATOR:
      return "UPDATE_PROGRESS_INDICATOR";
    case ClientUIActionType.UPDATE_SCORE_OR_PROGRESS:
      return "UPDATE_SCORE_OR_PROGRESS";
    case ClientUIActionType.SHOW_ELEMENT:
      return "SHOW_ELEMENT";
    case ClientUIActionType.HIDE_ELEMENT:
      return "HIDE_ELEMENT";
    case ClientUIActionType.NAVIGATE_TO_PAGE:
      return "NAVIGATE_TO_PAGE";
    case ClientUIActionType.UPDATE_LIVE_TRANSCRIPT:
      return "UPDATE_LIVE_TRANSCRIPT";
    case ClientUIActionType.DISPLAY_TRANSCRIPT_OR_TEXT:
      return "DISPLAY_TRANSCRIPT_OR_TEXT";
    case ClientUIActionType.DISPLAY_REMARKS_LIST:
      return "DISPLAY_REMARKS_LIST";
    case ClientUIActionType.SET_BUTTON_PROPERTIES:
      return "SET_BUTTON_PROPERTIES";
    case ClientUIActionType.ENABLE_BUTTON:
      return "ENABLE_BUTTON";
    case ClientUIActionType.DISABLE_BUTTON:
      return "DISABLE_BUTTON";
    case ClientUIActionType.SHOW_BUTTON_OPTIONS:
      return "SHOW_BUTTON_OPTIONS";
    case ClientUIActionType.CLEAR_INPUT_FIELD:
      return "CLEAR_INPUT_FIELD";
    case ClientUIActionType.SET_EDITOR_READONLY_SECTIONS:
      return "SET_EDITOR_READONLY_SECTIONS";
    case ClientUIActionType.SHOW_LOADING_INDICATOR:
      return "SHOW_LOADING_INDICATOR";
    case ClientUIActionType.HIGHLIGHT_TEXT_RANGES:
      return "HIGHLIGHT_TEXT_RANGES";
    case ClientUIActionType.SUGGEST_TEXT_EDIT:
      return "SUGGEST_TEXT_EDIT";
    case ClientUIActionType.SHOW_INLINE_SUGGESTION:
      return "SHOW_INLINE_SUGGESTION";
    case ClientUIActionType.SHOW_TOOLTIP_OR_COMMENT:
      return "SHOW_TOOLTIP_OR_COMMENT";
    case ClientUIActionType.SET_EDITOR_CONTENT:
      return "SET_EDITOR_CONTENT";
    case ClientUIActionType.APPEND_TEXT_TO_EDITOR_REALTIME:
      return "APPEND_TEXT_TO_EDITOR_REALTIME";
    case ClientUIActionType.STRIKETHROUGH_TEXT_RANGES:
      return "STRIKETHROUGH_TEXT_RANGES";
    case ClientUIActionType.START_LISTENING:
      return "START_LISTENING";
    case ClientUIActionType.STOP_LISTENING:
      return "STOP_LISTENING";
    case ClientUIActionType.EXECUTE_CONVERSATIONAL_SEQUENCE:
      return "EXECUTE_CONVERSATIONAL_SEQUENCE";
    case ClientUIActionType.PROMPT_FOR_USER_INPUT:
      return "PROMPT_FOR_USER_INPUT";
    case ClientUIActionType.START_LISTENING_VISUAL:
      return "START_LISTENING_VISUAL";
    case ClientUIActionType.STOP_LISTENING_VISUAL:
      return "STOP_LISTENING_VISUAL";
    case ClientUIActionType.SET_UI_STATE:
      return "SET_UI_STATE";
    case ClientUIActionType.DISPLAY_VISUAL_AID:
      return "DISPLAY_VISUAL_AID";
    case ClientUIActionType.FETCH_AND_DISPLAY_COURSE_MAP:
      return "FETCH_AND_DISPLAY_COURSE_MAP";
    case ClientUIActionType.END_DOUBT_LISTENING_SESSION:
      return "END_DOUBT_LISTENING_SESSION";
    case ClientUIActionType.START_DOUBT_LISTENING_SESSION:
      return "START_DOUBT_LISTENING_SESSION";
    case ClientUIActionType.REPLACE_TEXT_RANGE:
      return "REPLACE_TEXT_RANGE";
    case ClientUIActionType.SHOW_FEEDBACK:
      return "SHOW_FEEDBACK";
    case ClientUIActionType.HIGHLIGHT_ELEMENT:
      return "HIGHLIGHT_ELEMENT";
    case ClientUIActionType.GENERATE_VISUALIZATION:
      return "GENERATE_VISUALIZATION";
    case ClientUIActionType.HIGHLIGHT_ELEMENTS:
      return "HIGHLIGHT_ELEMENTS";
    case ClientUIActionType.GIVE_STUDENT_CONTROL:
      return "GIVE_STUDENT_CONTROL";
    case ClientUIActionType.TAKE_AI_CONTROL:
      return "TAKE_AI_CONTROL";
    case ClientUIActionType.CLEAR_ALL_ANNOTATIONS:
      return "CLEAR_ALL_ANNOTATIONS";
    case ClientUIActionType.JUPYTER_TYPE_IN_CELL:
      return "JUPYTER_TYPE_IN_CELL";
    case ClientUIActionType.JUPYTER_RUN_CELL:
      return "JUPYTER_RUN_CELL";
    case ClientUIActionType.JUPYTER_CREATE_NEW_CELL:
      return "JUPYTER_CREATE_NEW_CELL";
    case ClientUIActionType.JUPYTER_SCROLL_TO_CELL:
      return "JUPYTER_SCROLL_TO_CELL";
    case ClientUIActionType.JUPYTER_CLICK_PYODIDE:
      return "JUPYTER_CLICK_PYODIDE";
    case ClientUIActionType.BROWSER_NAVIGATE:
      return "BROWSER_NAVIGATE";
    case ClientUIActionType.BROWSER_CLICK:
      return "BROWSER_CLICK";
    case ClientUIActionType.BROWSER_TYPE:
      return "BROWSER_TYPE";
    case ClientUIActionType.UPLOAD_FILE_TO_JUPYTER:
      return "UPLOAD_FILE_TO_JUPYTER";
    case ClientUIActionType.HIGHLIGHT_CELL_FOR_DOUBT_RESOLUTION:
      return "HIGHLIGHT_CELL_FOR_DOUBT_RESOLUTION";
    case ClientUIActionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** For simple notifications if agent calls client and no specific response is needed. */
export interface Empty {
}

/** Message sent from frontend when a button is clicked */
export interface FrontendButtonClickRequest {
  /** Identifier for the button, e.g., "my_action_button" */
  buttonId: string;
  /** Optional: any string data you want to send */
  customData: string;
}

/** Response from the agent for the button click */
export interface AgentResponse {
  /** e.g., "Button click processed" */
  statusMessage: string;
  /** Optional: any data agent wants to return */
  dataPayload: string;
}

/** Message for dispatching UI actions to the frontend */
export interface UIAction {
  actionType: UIAction_ActionType;
  /** Payload for alert actions */
  alert?: Alert | undefined;
}

export enum UIAction_ActionType {
  UNSPECIFIED = 0,
  ALERT = 1,
  /**
   * DISMISS_ALERT - You can add other specific UI action types here later
   * e.g., SHOW_MODAL = 3; UPDATE_ELEMENT = 4;
   */
  DISMISS_ALERT = 2,
  UNRECOGNIZED = -1,
}

export function uIAction_ActionTypeFromJSON(object: any): UIAction_ActionType {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return UIAction_ActionType.UNSPECIFIED;
    case 1:
    case "ALERT":
      return UIAction_ActionType.ALERT;
    case 2:
    case "DISMISS_ALERT":
      return UIAction_ActionType.DISMISS_ALERT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UIAction_ActionType.UNRECOGNIZED;
  }
}

export function uIAction_ActionTypeToJSON(object: UIAction_ActionType): string {
  switch (object) {
    case UIAction_ActionType.UNSPECIFIED:
      return "UNSPECIFIED";
    case UIAction_ActionType.ALERT:
      return "ALERT";
    case UIAction_ActionType.DISMISS_ALERT:
      return "DISMISS_ALERT";
    case UIAction_ActionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Alert {
  title: string;
  message: string;
  buttons: AlertButton[];
}

export interface AlertButton {
  label: string;
  /** The action to perform when this button is clicked (e.g., DISMISS_ALERT) */
  action: UIAction | undefined;
}

/** Message sent from frontend on page load to notify the agent */
export interface NotifyPageLoadRequest {
  /** e.g., "ROX_WELCOME_INIT" */
  taskStage: string;
  /** User's identifier */
  userId: string;
  /** e.g., "P1_RoxHome" */
  currentPage: string;
  /** LiveKit Room SID or custom session ID */
  sessionId: string;
  /** Serialized chat history (e.g., JSON string) */
  chatHistory: string;
  /** Optional: e.g., "client_loaded_rox_page" */
  transcript?: string | undefined;
}

/** Message for generic RPC invocation data, if client constructs this based on proto */
export interface RpcInvocationData {
  /** Optional: if server needs to know caller from payload */
  callerIdentity: string;
  /** Base64 encoded actual protobuf message for the specific call */
  payload: string;
  /** Optional: for tracking */
  requestId: string;
}

/** A generic request to invoke a task on the agent/LangGraph */
export interface InvokeAgentTaskRequest {
  /** e.g., "handle_user_chat", "get_progress_report", "start_modelling_activity" */
  taskName: string;
  /** A flexible JSON string for any additional data */
  jsonPayload: string;
}

export interface PushToTalkRequest {
}

export interface UpdateAgentContextRequest {
  /** A JSON string of the context to merge */
  jsonContextPayload: string;
}

/** Message to represent a single text highlight range */
export interface HighlightRangeProto {
  /** Unique identifier for the highlight */
  id: string;
  /** Start position (ProseMirror index) */
  start: number;
  /** End position (ProseMirror index) */
  end: number;
  /** Type of highlight (e.g., 'grammar', 'suggestion') */
  type: string;
  /** Optional message/comment */
  message?:
    | string
    | undefined;
  /** Optional original text needing correction */
  wrongVersion?:
    | string
    | undefined;
  /** Optional suggested correction */
  correctVersion?: string | undefined;
}

/** Message to represent a single text strikethrough range */
export interface StrikeThroughRangeProto {
  /** Unique identifier for the strikethrough */
  id: string;
  /** Start position (ProseMirror index) */
  start: number;
  /** End position (ProseMirror index) */
  end: number;
  /** Type of strikethrough (e.g., 'deletion', 'suggestion') */
  type: string;
  /** Optional message/comment */
  message?: string | undefined;
}

/** Message to represent a single text edit suggestion */
export interface SuggestTextEditPayloadProto {
  /** Unique identifier for the suggestion */
  suggestionId: string;
  /** Start position (ProseMirror index) */
  startPos: number;
  /** End position (ProseMirror index) */
  endPos: number;
  /** The text to be replaced */
  originalText: string;
  /** The suggested new text */
  newText: string;
}

/** Message for showing an inline, non-intrusive suggestion */
export interface ShowInlineSuggestionPayloadProto {
  /** Unique ID for this suggestion */
  suggestionId: string;
  /** Start position in the editor (ProseMirror index) */
  startPos: number;
  /** End position in the editor (ProseMirror index) */
  endPos: number;
  /** Text to show on hover/click (e.g., "Consider rephrasing for clarity.") */
  suggestionText: string;
  /** Type of suggestion (e.g., "grammar", "style", "clarity") - for potential styling/iconography */
  suggestionType: string;
}

/** Message for showing a tooltip or comment */
export interface ShowTooltipOrCommentPayloadProto {
  /** Unique ID for this tooltip/comment */
  id: string;
  /** Start position in the editor (ProseMirror index) */
  startPos: number;
  /** End position in the editor (ProseMirror index) */
  endPos: number;
  /** The content of the tooltip/comment */
  text: string;
  /** E.g., "info", "suggestion", "error", "question" - for styling/iconography */
  tooltipType: string;
}

/** Message for setting the entire content of a rich text editor */
export interface SetEditorContentPayloadProto {
  contentFormat?:
    | //
    /** Full HTML content */
    { $case: "htmlContent"; htmlContent: string }
    | //
    /** Tiptap JSON content as a string */
    { $case: "jsonContent"; jsonContent: string }
    | undefined;
}

/** Message for appending text to an editor in real-time */
export interface AppendTextToEditorRealtimePayloadProto {
  /** The chunk of text to append */
  textChunk: string;
  /** Optional: ID to group related chunks if part of a continuous stream */
  streamId?:
    | string
    | undefined;
  /** Indicates if this is the last chunk in a stream */
  isFinalChunk?: boolean | undefined;
}

/** Message for displaying visual aid commands on a canvas */
export interface DisplayVisualAidPayloadProto {
  /** JSON string containing visual aid commands */
  commandsJson: string;
  /** Optional: ID of the canvas to target */
  canvasId?:
    | string
    | undefined;
  /** Optional: Whether to clear previous visual aids */
  clearPrevious?: boolean | undefined;
}

/** Payload for executing a conversational sequence */
export interface ExecuteConversationalSequencePayloadProto {
  /** JSON string containing the conversational sequence */
  sequenceJson: string;
}

/** Payload for displaying a list of remarks */
export interface DisplayRemarksListPayloadProto {
  /** List of remarks to display */
  remarks: RemarkProto[];
}

/** Definition of a remark */
export interface RemarkProto {
  /** Unique identifier for the remark */
  id: string;
  /** Title of the remark */
  title: string;
  /** Content of the remark */
  content: string;
  /** Optional type of remark (e.g., "feedback", "suggestion") */
  type?: string | undefined;
}

/** Payload for updating text content */
export interface UpdateTextContentPayloadProto {
  /** The text content to update */
  text: string;
}

/** Payload for replacing a range of text */
export interface ReplaceTextRangePayloadProto {
  /** Start index of the range */
  start: number;
  /** End index of the range */
  end: number;
  /** The text to replace the range with */
  replacement: string;
}

/** Request from Agent to Client to perform a UI action */
export interface AgentToClientUIActionRequest {
  /** Optional: for tracking/correlation */
  requestId: string;
  actionType: ClientUIActionType;
  /** Optional: ID of the HTML element to target */
  targetElementId: string;
  /** Flexible parameters, e.g., */
  parameters: { [key: string]: string };
  /** Payload for HIGHLIGHT_TEXT_RANGES */
  highlightRangesPayload: HighlightRangeProto[];
  /** Payload for SUGGEST_TEXT_EDIT */
  suggestTextEditPayload?:
    | SuggestTextEditPayloadProto
    | undefined;
  /** Payload for SHOW_INLINE_SUGGESTION */
  showInlineSuggestionPayload?:
    | ShowInlineSuggestionPayloadProto
    | undefined;
  /** Payload for SHOW_TOOLTIP_OR_COMMENT */
  showTooltipOrCommentPayload?:
    | ShowTooltipOrCommentPayloadProto
    | undefined;
  /** Payload for SET_EDITOR_CONTENT */
  setEditorContentPayload?:
    | SetEditorContentPayloadProto
    | undefined;
  /** Payload for APPEND_TEXT_TO_EDITOR_REALTIME */
  appendTextToEditorRealtimePayload?:
    | AppendTextToEditorRealtimePayloadProto
    | undefined;
  /** Payload for STRIKETHROUGH_TEXT_RANGES */
  strikethroughRangesPayload: StrikeThroughRangeProto[];
  /** Payload for DISPLAY_VISUAL_AID */
  displayVisualAidPayload?:
    | DisplayVisualAidPayloadProto
    | undefined;
  /** Payload for EXECUTE_CONVERSATIONAL_SEQUENCE */
  executeConversationalSequencePayload?:
    | ExecuteConversationalSequencePayloadProto
    | undefined;
  /** Payload for DISPLAY_REMARKS_LIST */
  displayRemarksListPayload?:
    | DisplayRemarksListPayloadProto
    | undefined;
  /** Payload for UPDATE_TEXT_CONTENT */
  updateTextContentPayload?:
    | UpdateTextContentPayloadProto
    | undefined;
  /** Payload for REPLACE_TEXT_RANGE */
  replaceTextRangePayload?: ReplaceTextRangePayloadProto | undefined;
}

export interface AgentToClientUIActionRequest_ParametersEntry {
  key: string;
  value: string;
}

/** Response from Client to Agent after attempting the UI action */
export interface ClientUIActionResponse {
  /** Corresponds to AgentToClientUIActionRequest.request_id */
  requestId: string;
  success: boolean;
  /** e.g., "Alert shown", "Element #myText updated", "Error: Element #xyz not found" */
  message: string;
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Empty>): Empty {
    return Empty.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Empty>): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseFrontendButtonClickRequest(): FrontendButtonClickRequest {
  return { buttonId: "", customData: "" };
}

export const FrontendButtonClickRequest: MessageFns<FrontendButtonClickRequest> = {
  encode(message: FrontendButtonClickRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buttonId !== "") {
      writer.uint32(10).string(message.buttonId);
    }
    if (message.customData !== "") {
      writer.uint32(18).string(message.customData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FrontendButtonClickRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFrontendButtonClickRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.buttonId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customData = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FrontendButtonClickRequest {
    return {
      buttonId: isSet(object.buttonId) ? globalThis.String(object.buttonId) : "",
      customData: isSet(object.customData) ? globalThis.String(object.customData) : "",
    };
  },

  toJSON(message: FrontendButtonClickRequest): unknown {
    const obj: any = {};
    if (message.buttonId !== "") {
      obj.buttonId = message.buttonId;
    }
    if (message.customData !== "") {
      obj.customData = message.customData;
    }
    return obj;
  },

  create(base?: DeepPartial<FrontendButtonClickRequest>): FrontendButtonClickRequest {
    return FrontendButtonClickRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FrontendButtonClickRequest>): FrontendButtonClickRequest {
    const message = createBaseFrontendButtonClickRequest();
    message.buttonId = object.buttonId ?? "";
    message.customData = object.customData ?? "";
    return message;
  },
};

function createBaseAgentResponse(): AgentResponse {
  return { statusMessage: "", dataPayload: "" };
}

export const AgentResponse: MessageFns<AgentResponse> = {
  encode(message: AgentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statusMessage !== "") {
      writer.uint32(10).string(message.statusMessage);
    }
    if (message.dataPayload !== "") {
      writer.uint32(18).string(message.dataPayload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataPayload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentResponse {
    return {
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      dataPayload: isSet(object.dataPayload) ? globalThis.String(object.dataPayload) : "",
    };
  },

  toJSON(message: AgentResponse): unknown {
    const obj: any = {};
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.dataPayload !== "") {
      obj.dataPayload = message.dataPayload;
    }
    return obj;
  },

  create(base?: DeepPartial<AgentResponse>): AgentResponse {
    return AgentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgentResponse>): AgentResponse {
    const message = createBaseAgentResponse();
    message.statusMessage = object.statusMessage ?? "";
    message.dataPayload = object.dataPayload ?? "";
    return message;
  },
};

function createBaseUIAction(): UIAction {
  return { actionType: 0, alert: undefined };
}

export const UIAction: MessageFns<UIAction> = {
  encode(message: UIAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionType !== 0) {
      writer.uint32(8).int32(message.actionType);
    }
    if (message.alert !== undefined) {
      Alert.encode(message.alert, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UIAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUIAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.alert = Alert.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UIAction {
    return {
      actionType: isSet(object.actionType) ? uIAction_ActionTypeFromJSON(object.actionType) : 0,
      alert: isSet(object.alert) ? Alert.fromJSON(object.alert) : undefined,
    };
  },

  toJSON(message: UIAction): unknown {
    const obj: any = {};
    if (message.actionType !== 0) {
      obj.actionType = uIAction_ActionTypeToJSON(message.actionType);
    }
    if (message.alert !== undefined) {
      obj.alert = Alert.toJSON(message.alert);
    }
    return obj;
  },

  create(base?: DeepPartial<UIAction>): UIAction {
    return UIAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UIAction>): UIAction {
    const message = createBaseUIAction();
    message.actionType = object.actionType ?? 0;
    message.alert = (object.alert !== undefined && object.alert !== null) ? Alert.fromPartial(object.alert) : undefined;
    return message;
  },
};

function createBaseAlert(): Alert {
  return { title: "", message: "", buttons: [] };
}

export const Alert: MessageFns<Alert> = {
  encode(message: Alert, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.buttons) {
      AlertButton.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Alert {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.buttons.push(AlertButton.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Alert {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      buttons: globalThis.Array.isArray(object?.buttons) ? object.buttons.map((e: any) => AlertButton.fromJSON(e)) : [],
    };
  },

  toJSON(message: Alert): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.buttons?.length) {
      obj.buttons = message.buttons.map((e) => AlertButton.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Alert>): Alert {
    return Alert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Alert>): Alert {
    const message = createBaseAlert();
    message.title = object.title ?? "";
    message.message = object.message ?? "";
    message.buttons = object.buttons?.map((e) => AlertButton.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAlertButton(): AlertButton {
  return { label: "", action: undefined };
}

export const AlertButton: MessageFns<AlertButton> = {
  encode(message: AlertButton, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.action !== undefined) {
      UIAction.encode(message.action, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertButton {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertButton();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = UIAction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertButton {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      action: isSet(object.action) ? UIAction.fromJSON(object.action) : undefined,
    };
  },

  toJSON(message: AlertButton): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.action !== undefined) {
      obj.action = UIAction.toJSON(message.action);
    }
    return obj;
  },

  create(base?: DeepPartial<AlertButton>): AlertButton {
    return AlertButton.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlertButton>): AlertButton {
    const message = createBaseAlertButton();
    message.label = object.label ?? "";
    message.action = (object.action !== undefined && object.action !== null)
      ? UIAction.fromPartial(object.action)
      : undefined;
    return message;
  },
};

function createBaseNotifyPageLoadRequest(): NotifyPageLoadRequest {
  return { taskStage: "", userId: "", currentPage: "", sessionId: "", chatHistory: "", transcript: undefined };
}

export const NotifyPageLoadRequest: MessageFns<NotifyPageLoadRequest> = {
  encode(message: NotifyPageLoadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskStage !== "") {
      writer.uint32(10).string(message.taskStage);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.currentPage !== "") {
      writer.uint32(26).string(message.currentPage);
    }
    if (message.sessionId !== "") {
      writer.uint32(34).string(message.sessionId);
    }
    if (message.chatHistory !== "") {
      writer.uint32(42).string(message.chatHistory);
    }
    if (message.transcript !== undefined) {
      writer.uint32(50).string(message.transcript);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotifyPageLoadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotifyPageLoadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskStage = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currentPage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.chatHistory = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.transcript = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotifyPageLoadRequest {
    return {
      taskStage: isSet(object.taskStage) ? globalThis.String(object.taskStage) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      currentPage: isSet(object.currentPage) ? globalThis.String(object.currentPage) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      chatHistory: isSet(object.chatHistory) ? globalThis.String(object.chatHistory) : "",
      transcript: isSet(object.transcript) ? globalThis.String(object.transcript) : undefined,
    };
  },

  toJSON(message: NotifyPageLoadRequest): unknown {
    const obj: any = {};
    if (message.taskStage !== "") {
      obj.taskStage = message.taskStage;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.currentPage !== "") {
      obj.currentPage = message.currentPage;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.chatHistory !== "") {
      obj.chatHistory = message.chatHistory;
    }
    if (message.transcript !== undefined) {
      obj.transcript = message.transcript;
    }
    return obj;
  },

  create(base?: DeepPartial<NotifyPageLoadRequest>): NotifyPageLoadRequest {
    return NotifyPageLoadRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotifyPageLoadRequest>): NotifyPageLoadRequest {
    const message = createBaseNotifyPageLoadRequest();
    message.taskStage = object.taskStage ?? "";
    message.userId = object.userId ?? "";
    message.currentPage = object.currentPage ?? "";
    message.sessionId = object.sessionId ?? "";
    message.chatHistory = object.chatHistory ?? "";
    message.transcript = object.transcript ?? undefined;
    return message;
  },
};

function createBaseRpcInvocationData(): RpcInvocationData {
  return { callerIdentity: "", payload: "", requestId: "" };
}

export const RpcInvocationData: MessageFns<RpcInvocationData> = {
  encode(message: RpcInvocationData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callerIdentity !== "") {
      writer.uint32(10).string(message.callerIdentity);
    }
    if (message.payload !== "") {
      writer.uint32(18).string(message.payload);
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpcInvocationData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpcInvocationData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.callerIdentity = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RpcInvocationData {
    return {
      callerIdentity: isSet(object.callerIdentity) ? globalThis.String(object.callerIdentity) : "",
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: RpcInvocationData): unknown {
    const obj: any = {};
    if (message.callerIdentity !== "") {
      obj.callerIdentity = message.callerIdentity;
    }
    if (message.payload !== "") {
      obj.payload = message.payload;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<RpcInvocationData>): RpcInvocationData {
    return RpcInvocationData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpcInvocationData>): RpcInvocationData {
    const message = createBaseRpcInvocationData();
    message.callerIdentity = object.callerIdentity ?? "";
    message.payload = object.payload ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseInvokeAgentTaskRequest(): InvokeAgentTaskRequest {
  return { taskName: "", jsonPayload: "" };
}

export const InvokeAgentTaskRequest: MessageFns<InvokeAgentTaskRequest> = {
  encode(message: InvokeAgentTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskName !== "") {
      writer.uint32(10).string(message.taskName);
    }
    if (message.jsonPayload !== "") {
      writer.uint32(18).string(message.jsonPayload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvokeAgentTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeAgentTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jsonPayload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeAgentTaskRequest {
    return {
      taskName: isSet(object.taskName) ? globalThis.String(object.taskName) : "",
      jsonPayload: isSet(object.jsonPayload) ? globalThis.String(object.jsonPayload) : "",
    };
  },

  toJSON(message: InvokeAgentTaskRequest): unknown {
    const obj: any = {};
    if (message.taskName !== "") {
      obj.taskName = message.taskName;
    }
    if (message.jsonPayload !== "") {
      obj.jsonPayload = message.jsonPayload;
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeAgentTaskRequest>): InvokeAgentTaskRequest {
    return InvokeAgentTaskRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeAgentTaskRequest>): InvokeAgentTaskRequest {
    const message = createBaseInvokeAgentTaskRequest();
    message.taskName = object.taskName ?? "";
    message.jsonPayload = object.jsonPayload ?? "";
    return message;
  },
};

function createBasePushToTalkRequest(): PushToTalkRequest {
  return {};
}

export const PushToTalkRequest: MessageFns<PushToTalkRequest> = {
  encode(_: PushToTalkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PushToTalkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePushToTalkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PushToTalkRequest {
    return {};
  },

  toJSON(_: PushToTalkRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PushToTalkRequest>): PushToTalkRequest {
    return PushToTalkRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PushToTalkRequest>): PushToTalkRequest {
    const message = createBasePushToTalkRequest();
    return message;
  },
};

function createBaseUpdateAgentContextRequest(): UpdateAgentContextRequest {
  return { jsonContextPayload: "" };
}

export const UpdateAgentContextRequest: MessageFns<UpdateAgentContextRequest> = {
  encode(message: UpdateAgentContextRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jsonContextPayload !== "") {
      writer.uint32(10).string(message.jsonContextPayload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAgentContextRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAgentContextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jsonContextPayload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAgentContextRequest {
    return { jsonContextPayload: isSet(object.jsonContextPayload) ? globalThis.String(object.jsonContextPayload) : "" };
  },

  toJSON(message: UpdateAgentContextRequest): unknown {
    const obj: any = {};
    if (message.jsonContextPayload !== "") {
      obj.jsonContextPayload = message.jsonContextPayload;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAgentContextRequest>): UpdateAgentContextRequest {
    return UpdateAgentContextRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAgentContextRequest>): UpdateAgentContextRequest {
    const message = createBaseUpdateAgentContextRequest();
    message.jsonContextPayload = object.jsonContextPayload ?? "";
    return message;
  },
};

function createBaseHighlightRangeProto(): HighlightRangeProto {
  return { id: "", start: 0, end: 0, type: "", message: undefined, wrongVersion: undefined, correctVersion: undefined };
}

export const HighlightRangeProto: MessageFns<HighlightRangeProto> = {
  encode(message: HighlightRangeProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.start !== 0) {
      writer.uint32(16).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(24).int32(message.end);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.message !== undefined) {
      writer.uint32(42).string(message.message);
    }
    if (message.wrongVersion !== undefined) {
      writer.uint32(50).string(message.wrongVersion);
    }
    if (message.correctVersion !== undefined) {
      writer.uint32(58).string(message.correctVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HighlightRangeProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHighlightRangeProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.start = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.end = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.wrongVersion = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.correctVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HighlightRangeProto {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
      wrongVersion: isSet(object.wrongVersion) ? globalThis.String(object.wrongVersion) : undefined,
      correctVersion: isSet(object.correctVersion) ? globalThis.String(object.correctVersion) : undefined,
    };
  },

  toJSON(message: HighlightRangeProto): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    if (message.wrongVersion !== undefined) {
      obj.wrongVersion = message.wrongVersion;
    }
    if (message.correctVersion !== undefined) {
      obj.correctVersion = message.correctVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<HighlightRangeProto>): HighlightRangeProto {
    return HighlightRangeProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HighlightRangeProto>): HighlightRangeProto {
    const message = createBaseHighlightRangeProto();
    message.id = object.id ?? "";
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    message.type = object.type ?? "";
    message.message = object.message ?? undefined;
    message.wrongVersion = object.wrongVersion ?? undefined;
    message.correctVersion = object.correctVersion ?? undefined;
    return message;
  },
};

function createBaseStrikeThroughRangeProto(): StrikeThroughRangeProto {
  return { id: "", start: 0, end: 0, type: "", message: undefined };
}

export const StrikeThroughRangeProto: MessageFns<StrikeThroughRangeProto> = {
  encode(message: StrikeThroughRangeProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.start !== 0) {
      writer.uint32(16).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(24).int32(message.end);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.message !== undefined) {
      writer.uint32(42).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StrikeThroughRangeProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrikeThroughRangeProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.start = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.end = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StrikeThroughRangeProto {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: StrikeThroughRangeProto): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<StrikeThroughRangeProto>): StrikeThroughRangeProto {
    return StrikeThroughRangeProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StrikeThroughRangeProto>): StrikeThroughRangeProto {
    const message = createBaseStrikeThroughRangeProto();
    message.id = object.id ?? "";
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    message.type = object.type ?? "";
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseSuggestTextEditPayloadProto(): SuggestTextEditPayloadProto {
  return { suggestionId: "", startPos: 0, endPos: 0, originalText: "", newText: "" };
}

export const SuggestTextEditPayloadProto: MessageFns<SuggestTextEditPayloadProto> = {
  encode(message: SuggestTextEditPayloadProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.suggestionId !== "") {
      writer.uint32(10).string(message.suggestionId);
    }
    if (message.startPos !== 0) {
      writer.uint32(16).int32(message.startPos);
    }
    if (message.endPos !== 0) {
      writer.uint32(24).int32(message.endPos);
    }
    if (message.originalText !== "") {
      writer.uint32(34).string(message.originalText);
    }
    if (message.newText !== "") {
      writer.uint32(42).string(message.newText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestTextEditPayloadProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestTextEditPayloadProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.suggestionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startPos = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.endPos = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.originalText = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.newText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestTextEditPayloadProto {
    return {
      suggestionId: isSet(object.suggestionId) ? globalThis.String(object.suggestionId) : "",
      startPos: isSet(object.startPos) ? globalThis.Number(object.startPos) : 0,
      endPos: isSet(object.endPos) ? globalThis.Number(object.endPos) : 0,
      originalText: isSet(object.originalText) ? globalThis.String(object.originalText) : "",
      newText: isSet(object.newText) ? globalThis.String(object.newText) : "",
    };
  },

  toJSON(message: SuggestTextEditPayloadProto): unknown {
    const obj: any = {};
    if (message.suggestionId !== "") {
      obj.suggestionId = message.suggestionId;
    }
    if (message.startPos !== 0) {
      obj.startPos = Math.round(message.startPos);
    }
    if (message.endPos !== 0) {
      obj.endPos = Math.round(message.endPos);
    }
    if (message.originalText !== "") {
      obj.originalText = message.originalText;
    }
    if (message.newText !== "") {
      obj.newText = message.newText;
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestTextEditPayloadProto>): SuggestTextEditPayloadProto {
    return SuggestTextEditPayloadProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestTextEditPayloadProto>): SuggestTextEditPayloadProto {
    const message = createBaseSuggestTextEditPayloadProto();
    message.suggestionId = object.suggestionId ?? "";
    message.startPos = object.startPos ?? 0;
    message.endPos = object.endPos ?? 0;
    message.originalText = object.originalText ?? "";
    message.newText = object.newText ?? "";
    return message;
  },
};

function createBaseShowInlineSuggestionPayloadProto(): ShowInlineSuggestionPayloadProto {
  return { suggestionId: "", startPos: 0, endPos: 0, suggestionText: "", suggestionType: "" };
}

export const ShowInlineSuggestionPayloadProto: MessageFns<ShowInlineSuggestionPayloadProto> = {
  encode(message: ShowInlineSuggestionPayloadProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.suggestionId !== "") {
      writer.uint32(10).string(message.suggestionId);
    }
    if (message.startPos !== 0) {
      writer.uint32(16).int32(message.startPos);
    }
    if (message.endPos !== 0) {
      writer.uint32(24).int32(message.endPos);
    }
    if (message.suggestionText !== "") {
      writer.uint32(34).string(message.suggestionText);
    }
    if (message.suggestionType !== "") {
      writer.uint32(42).string(message.suggestionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShowInlineSuggestionPayloadProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShowInlineSuggestionPayloadProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.suggestionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startPos = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.endPos = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.suggestionText = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.suggestionType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShowInlineSuggestionPayloadProto {
    return {
      suggestionId: isSet(object.suggestionId) ? globalThis.String(object.suggestionId) : "",
      startPos: isSet(object.startPos) ? globalThis.Number(object.startPos) : 0,
      endPos: isSet(object.endPos) ? globalThis.Number(object.endPos) : 0,
      suggestionText: isSet(object.suggestionText) ? globalThis.String(object.suggestionText) : "",
      suggestionType: isSet(object.suggestionType) ? globalThis.String(object.suggestionType) : "",
    };
  },

  toJSON(message: ShowInlineSuggestionPayloadProto): unknown {
    const obj: any = {};
    if (message.suggestionId !== "") {
      obj.suggestionId = message.suggestionId;
    }
    if (message.startPos !== 0) {
      obj.startPos = Math.round(message.startPos);
    }
    if (message.endPos !== 0) {
      obj.endPos = Math.round(message.endPos);
    }
    if (message.suggestionText !== "") {
      obj.suggestionText = message.suggestionText;
    }
    if (message.suggestionType !== "") {
      obj.suggestionType = message.suggestionType;
    }
    return obj;
  },

  create(base?: DeepPartial<ShowInlineSuggestionPayloadProto>): ShowInlineSuggestionPayloadProto {
    return ShowInlineSuggestionPayloadProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShowInlineSuggestionPayloadProto>): ShowInlineSuggestionPayloadProto {
    const message = createBaseShowInlineSuggestionPayloadProto();
    message.suggestionId = object.suggestionId ?? "";
    message.startPos = object.startPos ?? 0;
    message.endPos = object.endPos ?? 0;
    message.suggestionText = object.suggestionText ?? "";
    message.suggestionType = object.suggestionType ?? "";
    return message;
  },
};

function createBaseShowTooltipOrCommentPayloadProto(): ShowTooltipOrCommentPayloadProto {
  return { id: "", startPos: 0, endPos: 0, text: "", tooltipType: "" };
}

export const ShowTooltipOrCommentPayloadProto: MessageFns<ShowTooltipOrCommentPayloadProto> = {
  encode(message: ShowTooltipOrCommentPayloadProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.startPos !== 0) {
      writer.uint32(16).int32(message.startPos);
    }
    if (message.endPos !== 0) {
      writer.uint32(24).int32(message.endPos);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.tooltipType !== "") {
      writer.uint32(42).string(message.tooltipType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShowTooltipOrCommentPayloadProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShowTooltipOrCommentPayloadProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startPos = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.endPos = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tooltipType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShowTooltipOrCommentPayloadProto {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      startPos: isSet(object.startPos) ? globalThis.Number(object.startPos) : 0,
      endPos: isSet(object.endPos) ? globalThis.Number(object.endPos) : 0,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      tooltipType: isSet(object.tooltipType) ? globalThis.String(object.tooltipType) : "",
    };
  },

  toJSON(message: ShowTooltipOrCommentPayloadProto): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.startPos !== 0) {
      obj.startPos = Math.round(message.startPos);
    }
    if (message.endPos !== 0) {
      obj.endPos = Math.round(message.endPos);
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.tooltipType !== "") {
      obj.tooltipType = message.tooltipType;
    }
    return obj;
  },

  create(base?: DeepPartial<ShowTooltipOrCommentPayloadProto>): ShowTooltipOrCommentPayloadProto {
    return ShowTooltipOrCommentPayloadProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShowTooltipOrCommentPayloadProto>): ShowTooltipOrCommentPayloadProto {
    const message = createBaseShowTooltipOrCommentPayloadProto();
    message.id = object.id ?? "";
    message.startPos = object.startPos ?? 0;
    message.endPos = object.endPos ?? 0;
    message.text = object.text ?? "";
    message.tooltipType = object.tooltipType ?? "";
    return message;
  },
};

function createBaseSetEditorContentPayloadProto(): SetEditorContentPayloadProto {
  return { contentFormat: undefined };
}

export const SetEditorContentPayloadProto: MessageFns<SetEditorContentPayloadProto> = {
  encode(message: SetEditorContentPayloadProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.contentFormat?.$case) {
      case "htmlContent":
        writer.uint32(10).string(message.contentFormat.htmlContent);
        break;
      case "jsonContent":
        writer.uint32(18).string(message.contentFormat.jsonContent);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetEditorContentPayloadProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetEditorContentPayloadProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contentFormat = { $case: "htmlContent", htmlContent: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentFormat = { $case: "jsonContent", jsonContent: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetEditorContentPayloadProto {
    return {
      contentFormat: isSet(object.htmlContent)
        ? { $case: "htmlContent", htmlContent: globalThis.String(object.htmlContent) }
        : isSet(object.jsonContent)
        ? { $case: "jsonContent", jsonContent: globalThis.String(object.jsonContent) }
        : undefined,
    };
  },

  toJSON(message: SetEditorContentPayloadProto): unknown {
    const obj: any = {};
    if (message.contentFormat?.$case === "htmlContent") {
      obj.htmlContent = message.contentFormat.htmlContent;
    } else if (message.contentFormat?.$case === "jsonContent") {
      obj.jsonContent = message.contentFormat.jsonContent;
    }
    return obj;
  },

  create(base?: DeepPartial<SetEditorContentPayloadProto>): SetEditorContentPayloadProto {
    return SetEditorContentPayloadProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetEditorContentPayloadProto>): SetEditorContentPayloadProto {
    const message = createBaseSetEditorContentPayloadProto();
    switch (object.contentFormat?.$case) {
      case "htmlContent": {
        if (object.contentFormat?.htmlContent !== undefined && object.contentFormat?.htmlContent !== null) {
          message.contentFormat = { $case: "htmlContent", htmlContent: object.contentFormat.htmlContent };
        }
        break;
      }
      case "jsonContent": {
        if (object.contentFormat?.jsonContent !== undefined && object.contentFormat?.jsonContent !== null) {
          message.contentFormat = { $case: "jsonContent", jsonContent: object.contentFormat.jsonContent };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseAppendTextToEditorRealtimePayloadProto(): AppendTextToEditorRealtimePayloadProto {
  return { textChunk: "", streamId: undefined, isFinalChunk: undefined };
}

export const AppendTextToEditorRealtimePayloadProto: MessageFns<AppendTextToEditorRealtimePayloadProto> = {
  encode(message: AppendTextToEditorRealtimePayloadProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textChunk !== "") {
      writer.uint32(10).string(message.textChunk);
    }
    if (message.streamId !== undefined) {
      writer.uint32(18).string(message.streamId);
    }
    if (message.isFinalChunk !== undefined) {
      writer.uint32(24).bool(message.isFinalChunk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppendTextToEditorRealtimePayloadProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppendTextToEditorRealtimePayloadProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.textChunk = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.streamId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isFinalChunk = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppendTextToEditorRealtimePayloadProto {
    return {
      textChunk: isSet(object.textChunk) ? globalThis.String(object.textChunk) : "",
      streamId: isSet(object.streamId) ? globalThis.String(object.streamId) : undefined,
      isFinalChunk: isSet(object.isFinalChunk) ? globalThis.Boolean(object.isFinalChunk) : undefined,
    };
  },

  toJSON(message: AppendTextToEditorRealtimePayloadProto): unknown {
    const obj: any = {};
    if (message.textChunk !== "") {
      obj.textChunk = message.textChunk;
    }
    if (message.streamId !== undefined) {
      obj.streamId = message.streamId;
    }
    if (message.isFinalChunk !== undefined) {
      obj.isFinalChunk = message.isFinalChunk;
    }
    return obj;
  },

  create(base?: DeepPartial<AppendTextToEditorRealtimePayloadProto>): AppendTextToEditorRealtimePayloadProto {
    return AppendTextToEditorRealtimePayloadProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppendTextToEditorRealtimePayloadProto>): AppendTextToEditorRealtimePayloadProto {
    const message = createBaseAppendTextToEditorRealtimePayloadProto();
    message.textChunk = object.textChunk ?? "";
    message.streamId = object.streamId ?? undefined;
    message.isFinalChunk = object.isFinalChunk ?? undefined;
    return message;
  },
};

function createBaseDisplayVisualAidPayloadProto(): DisplayVisualAidPayloadProto {
  return { commandsJson: "", canvasId: undefined, clearPrevious: undefined };
}

export const DisplayVisualAidPayloadProto: MessageFns<DisplayVisualAidPayloadProto> = {
  encode(message: DisplayVisualAidPayloadProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandsJson !== "") {
      writer.uint32(10).string(message.commandsJson);
    }
    if (message.canvasId !== undefined) {
      writer.uint32(18).string(message.canvasId);
    }
    if (message.clearPrevious !== undefined) {
      writer.uint32(24).bool(message.clearPrevious);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisplayVisualAidPayloadProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisplayVisualAidPayloadProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commandsJson = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.canvasId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.clearPrevious = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisplayVisualAidPayloadProto {
    return {
      commandsJson: isSet(object.commandsJson) ? globalThis.String(object.commandsJson) : "",
      canvasId: isSet(object.canvasId) ? globalThis.String(object.canvasId) : undefined,
      clearPrevious: isSet(object.clearPrevious) ? globalThis.Boolean(object.clearPrevious) : undefined,
    };
  },

  toJSON(message: DisplayVisualAidPayloadProto): unknown {
    const obj: any = {};
    if (message.commandsJson !== "") {
      obj.commandsJson = message.commandsJson;
    }
    if (message.canvasId !== undefined) {
      obj.canvasId = message.canvasId;
    }
    if (message.clearPrevious !== undefined) {
      obj.clearPrevious = message.clearPrevious;
    }
    return obj;
  },

  create(base?: DeepPartial<DisplayVisualAidPayloadProto>): DisplayVisualAidPayloadProto {
    return DisplayVisualAidPayloadProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DisplayVisualAidPayloadProto>): DisplayVisualAidPayloadProto {
    const message = createBaseDisplayVisualAidPayloadProto();
    message.commandsJson = object.commandsJson ?? "";
    message.canvasId = object.canvasId ?? undefined;
    message.clearPrevious = object.clearPrevious ?? undefined;
    return message;
  },
};

function createBaseExecuteConversationalSequencePayloadProto(): ExecuteConversationalSequencePayloadProto {
  return { sequenceJson: "" };
}

export const ExecuteConversationalSequencePayloadProto: MessageFns<ExecuteConversationalSequencePayloadProto> = {
  encode(message: ExecuteConversationalSequencePayloadProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sequenceJson !== "") {
      writer.uint32(10).string(message.sequenceJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteConversationalSequencePayloadProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteConversationalSequencePayloadProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sequenceJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteConversationalSequencePayloadProto {
    return { sequenceJson: isSet(object.sequenceJson) ? globalThis.String(object.sequenceJson) : "" };
  },

  toJSON(message: ExecuteConversationalSequencePayloadProto): unknown {
    const obj: any = {};
    if (message.sequenceJson !== "") {
      obj.sequenceJson = message.sequenceJson;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteConversationalSequencePayloadProto>): ExecuteConversationalSequencePayloadProto {
    return ExecuteConversationalSequencePayloadProto.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ExecuteConversationalSequencePayloadProto>,
  ): ExecuteConversationalSequencePayloadProto {
    const message = createBaseExecuteConversationalSequencePayloadProto();
    message.sequenceJson = object.sequenceJson ?? "";
    return message;
  },
};

function createBaseDisplayRemarksListPayloadProto(): DisplayRemarksListPayloadProto {
  return { remarks: [] };
}

export const DisplayRemarksListPayloadProto: MessageFns<DisplayRemarksListPayloadProto> = {
  encode(message: DisplayRemarksListPayloadProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.remarks) {
      RemarkProto.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisplayRemarksListPayloadProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisplayRemarksListPayloadProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.remarks.push(RemarkProto.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisplayRemarksListPayloadProto {
    return {
      remarks: globalThis.Array.isArray(object?.remarks) ? object.remarks.map((e: any) => RemarkProto.fromJSON(e)) : [],
    };
  },

  toJSON(message: DisplayRemarksListPayloadProto): unknown {
    const obj: any = {};
    if (message.remarks?.length) {
      obj.remarks = message.remarks.map((e) => RemarkProto.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DisplayRemarksListPayloadProto>): DisplayRemarksListPayloadProto {
    return DisplayRemarksListPayloadProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DisplayRemarksListPayloadProto>): DisplayRemarksListPayloadProto {
    const message = createBaseDisplayRemarksListPayloadProto();
    message.remarks = object.remarks?.map((e) => RemarkProto.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRemarkProto(): RemarkProto {
  return { id: "", title: "", content: "", type: undefined };
}

export const RemarkProto: MessageFns<RemarkProto> = {
  encode(message: RemarkProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.type !== undefined) {
      writer.uint32(34).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemarkProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemarkProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemarkProto {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
    };
  },

  toJSON(message: RemarkProto): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    return obj;
  },

  create(base?: DeepPartial<RemarkProto>): RemarkProto {
    return RemarkProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemarkProto>): RemarkProto {
    const message = createBaseRemarkProto();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.content = object.content ?? "";
    message.type = object.type ?? undefined;
    return message;
  },
};

function createBaseUpdateTextContentPayloadProto(): UpdateTextContentPayloadProto {
  return { text: "" };
}

export const UpdateTextContentPayloadProto: MessageFns<UpdateTextContentPayloadProto> = {
  encode(message: UpdateTextContentPayloadProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTextContentPayloadProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTextContentPayloadProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTextContentPayloadProto {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: UpdateTextContentPayloadProto): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateTextContentPayloadProto>): UpdateTextContentPayloadProto {
    return UpdateTextContentPayloadProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateTextContentPayloadProto>): UpdateTextContentPayloadProto {
    const message = createBaseUpdateTextContentPayloadProto();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseReplaceTextRangePayloadProto(): ReplaceTextRangePayloadProto {
  return { start: 0, end: 0, replacement: "" };
}

export const ReplaceTextRangePayloadProto: MessageFns<ReplaceTextRangePayloadProto> = {
  encode(message: ReplaceTextRangePayloadProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    if (message.replacement !== "") {
      writer.uint32(26).string(message.replacement);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplaceTextRangePayloadProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplaceTextRangePayloadProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.start = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.end = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.replacement = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplaceTextRangePayloadProto {
    return {
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
      replacement: isSet(object.replacement) ? globalThis.String(object.replacement) : "",
    };
  },

  toJSON(message: ReplaceTextRangePayloadProto): unknown {
    const obj: any = {};
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    if (message.replacement !== "") {
      obj.replacement = message.replacement;
    }
    return obj;
  },

  create(base?: DeepPartial<ReplaceTextRangePayloadProto>): ReplaceTextRangePayloadProto {
    return ReplaceTextRangePayloadProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplaceTextRangePayloadProto>): ReplaceTextRangePayloadProto {
    const message = createBaseReplaceTextRangePayloadProto();
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    message.replacement = object.replacement ?? "";
    return message;
  },
};

function createBaseAgentToClientUIActionRequest(): AgentToClientUIActionRequest {
  return {
    requestId: "",
    actionType: 0,
    targetElementId: "",
    parameters: {},
    highlightRangesPayload: [],
    suggestTextEditPayload: undefined,
    showInlineSuggestionPayload: undefined,
    showTooltipOrCommentPayload: undefined,
    setEditorContentPayload: undefined,
    appendTextToEditorRealtimePayload: undefined,
    strikethroughRangesPayload: [],
    displayVisualAidPayload: undefined,
    executeConversationalSequencePayload: undefined,
    displayRemarksListPayload: undefined,
    updateTextContentPayload: undefined,
    replaceTextRangePayload: undefined,
  };
}

export const AgentToClientUIActionRequest: MessageFns<AgentToClientUIActionRequest> = {
  encode(message: AgentToClientUIActionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.actionType !== 0) {
      writer.uint32(16).int32(message.actionType);
    }
    if (message.targetElementId !== "") {
      writer.uint32(26).string(message.targetElementId);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      AgentToClientUIActionRequest_ParametersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    for (const v of message.highlightRangesPayload) {
      HighlightRangeProto.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.suggestTextEditPayload !== undefined) {
      SuggestTextEditPayloadProto.encode(message.suggestTextEditPayload, writer.uint32(50).fork()).join();
    }
    if (message.showInlineSuggestionPayload !== undefined) {
      ShowInlineSuggestionPayloadProto.encode(message.showInlineSuggestionPayload, writer.uint32(58).fork()).join();
    }
    if (message.showTooltipOrCommentPayload !== undefined) {
      ShowTooltipOrCommentPayloadProto.encode(message.showTooltipOrCommentPayload, writer.uint32(66).fork()).join();
    }
    if (message.setEditorContentPayload !== undefined) {
      SetEditorContentPayloadProto.encode(message.setEditorContentPayload, writer.uint32(74).fork()).join();
    }
    if (message.appendTextToEditorRealtimePayload !== undefined) {
      AppendTextToEditorRealtimePayloadProto.encode(message.appendTextToEditorRealtimePayload, writer.uint32(82).fork())
        .join();
    }
    for (const v of message.strikethroughRangesPayload) {
      StrikeThroughRangeProto.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.displayVisualAidPayload !== undefined) {
      DisplayVisualAidPayloadProto.encode(message.displayVisualAidPayload, writer.uint32(98).fork()).join();
    }
    if (message.executeConversationalSequencePayload !== undefined) {
      ExecuteConversationalSequencePayloadProto.encode(
        message.executeConversationalSequencePayload,
        writer.uint32(106).fork(),
      ).join();
    }
    if (message.displayRemarksListPayload !== undefined) {
      DisplayRemarksListPayloadProto.encode(message.displayRemarksListPayload, writer.uint32(114).fork()).join();
    }
    if (message.updateTextContentPayload !== undefined) {
      UpdateTextContentPayloadProto.encode(message.updateTextContentPayload, writer.uint32(122).fork()).join();
    }
    if (message.replaceTextRangePayload !== undefined) {
      ReplaceTextRangePayloadProto.encode(message.replaceTextRangePayload, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentToClientUIActionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentToClientUIActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetElementId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = AgentToClientUIActionRequest_ParametersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.parameters[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.highlightRangesPayload.push(HighlightRangeProto.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.suggestTextEditPayload = SuggestTextEditPayloadProto.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.showInlineSuggestionPayload = ShowInlineSuggestionPayloadProto.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.showTooltipOrCommentPayload = ShowTooltipOrCommentPayloadProto.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.setEditorContentPayload = SetEditorContentPayloadProto.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.appendTextToEditorRealtimePayload = AppendTextToEditorRealtimePayloadProto.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.strikethroughRangesPayload.push(StrikeThroughRangeProto.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.displayVisualAidPayload = DisplayVisualAidPayloadProto.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.executeConversationalSequencePayload = ExecuteConversationalSequencePayloadProto.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.displayRemarksListPayload = DisplayRemarksListPayloadProto.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.updateTextContentPayload = UpdateTextContentPayloadProto.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.replaceTextRangePayload = ReplaceTextRangePayloadProto.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentToClientUIActionRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      actionType: isSet(object.actionType) ? clientUIActionTypeFromJSON(object.actionType) : 0,
      targetElementId: isSet(object.targetElementId) ? globalThis.String(object.targetElementId) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      highlightRangesPayload: globalThis.Array.isArray(object?.highlightRangesPayload)
        ? object.highlightRangesPayload.map((e: any) => HighlightRangeProto.fromJSON(e))
        : [],
      suggestTextEditPayload: isSet(object.suggestTextEditPayload)
        ? SuggestTextEditPayloadProto.fromJSON(object.suggestTextEditPayload)
        : undefined,
      showInlineSuggestionPayload: isSet(object.showInlineSuggestionPayload)
        ? ShowInlineSuggestionPayloadProto.fromJSON(object.showInlineSuggestionPayload)
        : undefined,
      showTooltipOrCommentPayload: isSet(object.showTooltipOrCommentPayload)
        ? ShowTooltipOrCommentPayloadProto.fromJSON(object.showTooltipOrCommentPayload)
        : undefined,
      setEditorContentPayload: isSet(object.setEditorContentPayload)
        ? SetEditorContentPayloadProto.fromJSON(object.setEditorContentPayload)
        : undefined,
      appendTextToEditorRealtimePayload: isSet(object.appendTextToEditorRealtimePayload)
        ? AppendTextToEditorRealtimePayloadProto.fromJSON(object.appendTextToEditorRealtimePayload)
        : undefined,
      strikethroughRangesPayload: globalThis.Array.isArray(object?.strikethroughRangesPayload)
        ? object.strikethroughRangesPayload.map((e: any) => StrikeThroughRangeProto.fromJSON(e))
        : [],
      displayVisualAidPayload: isSet(object.displayVisualAidPayload)
        ? DisplayVisualAidPayloadProto.fromJSON(object.displayVisualAidPayload)
        : undefined,
      executeConversationalSequencePayload: isSet(object.executeConversationalSequencePayload)
        ? ExecuteConversationalSequencePayloadProto.fromJSON(object.executeConversationalSequencePayload)
        : undefined,
      displayRemarksListPayload: isSet(object.displayRemarksListPayload)
        ? DisplayRemarksListPayloadProto.fromJSON(object.displayRemarksListPayload)
        : undefined,
      updateTextContentPayload: isSet(object.updateTextContentPayload)
        ? UpdateTextContentPayloadProto.fromJSON(object.updateTextContentPayload)
        : undefined,
      replaceTextRangePayload: isSet(object.replaceTextRangePayload)
        ? ReplaceTextRangePayloadProto.fromJSON(object.replaceTextRangePayload)
        : undefined,
    };
  },

  toJSON(message: AgentToClientUIActionRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.actionType !== 0) {
      obj.actionType = clientUIActionTypeToJSON(message.actionType);
    }
    if (message.targetElementId !== "") {
      obj.targetElementId = message.targetElementId;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = v;
        });
      }
    }
    if (message.highlightRangesPayload?.length) {
      obj.highlightRangesPayload = message.highlightRangesPayload.map((e) => HighlightRangeProto.toJSON(e));
    }
    if (message.suggestTextEditPayload !== undefined) {
      obj.suggestTextEditPayload = SuggestTextEditPayloadProto.toJSON(message.suggestTextEditPayload);
    }
    if (message.showInlineSuggestionPayload !== undefined) {
      obj.showInlineSuggestionPayload = ShowInlineSuggestionPayloadProto.toJSON(message.showInlineSuggestionPayload);
    }
    if (message.showTooltipOrCommentPayload !== undefined) {
      obj.showTooltipOrCommentPayload = ShowTooltipOrCommentPayloadProto.toJSON(message.showTooltipOrCommentPayload);
    }
    if (message.setEditorContentPayload !== undefined) {
      obj.setEditorContentPayload = SetEditorContentPayloadProto.toJSON(message.setEditorContentPayload);
    }
    if (message.appendTextToEditorRealtimePayload !== undefined) {
      obj.appendTextToEditorRealtimePayload = AppendTextToEditorRealtimePayloadProto.toJSON(
        message.appendTextToEditorRealtimePayload,
      );
    }
    if (message.strikethroughRangesPayload?.length) {
      obj.strikethroughRangesPayload = message.strikethroughRangesPayload.map((e) => StrikeThroughRangeProto.toJSON(e));
    }
    if (message.displayVisualAidPayload !== undefined) {
      obj.displayVisualAidPayload = DisplayVisualAidPayloadProto.toJSON(message.displayVisualAidPayload);
    }
    if (message.executeConversationalSequencePayload !== undefined) {
      obj.executeConversationalSequencePayload = ExecuteConversationalSequencePayloadProto.toJSON(
        message.executeConversationalSequencePayload,
      );
    }
    if (message.displayRemarksListPayload !== undefined) {
      obj.displayRemarksListPayload = DisplayRemarksListPayloadProto.toJSON(message.displayRemarksListPayload);
    }
    if (message.updateTextContentPayload !== undefined) {
      obj.updateTextContentPayload = UpdateTextContentPayloadProto.toJSON(message.updateTextContentPayload);
    }
    if (message.replaceTextRangePayload !== undefined) {
      obj.replaceTextRangePayload = ReplaceTextRangePayloadProto.toJSON(message.replaceTextRangePayload);
    }
    return obj;
  },

  create(base?: DeepPartial<AgentToClientUIActionRequest>): AgentToClientUIActionRequest {
    return AgentToClientUIActionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgentToClientUIActionRequest>): AgentToClientUIActionRequest {
    const message = createBaseAgentToClientUIActionRequest();
    message.requestId = object.requestId ?? "";
    message.actionType = object.actionType ?? 0;
    message.targetElementId = object.targetElementId ?? "";
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.highlightRangesPayload = object.highlightRangesPayload?.map((e) => HighlightRangeProto.fromPartial(e)) ||
      [];
    message.suggestTextEditPayload =
      (object.suggestTextEditPayload !== undefined && object.suggestTextEditPayload !== null)
        ? SuggestTextEditPayloadProto.fromPartial(object.suggestTextEditPayload)
        : undefined;
    message.showInlineSuggestionPayload =
      (object.showInlineSuggestionPayload !== undefined && object.showInlineSuggestionPayload !== null)
        ? ShowInlineSuggestionPayloadProto.fromPartial(object.showInlineSuggestionPayload)
        : undefined;
    message.showTooltipOrCommentPayload =
      (object.showTooltipOrCommentPayload !== undefined && object.showTooltipOrCommentPayload !== null)
        ? ShowTooltipOrCommentPayloadProto.fromPartial(object.showTooltipOrCommentPayload)
        : undefined;
    message.setEditorContentPayload =
      (object.setEditorContentPayload !== undefined && object.setEditorContentPayload !== null)
        ? SetEditorContentPayloadProto.fromPartial(object.setEditorContentPayload)
        : undefined;
    message.appendTextToEditorRealtimePayload =
      (object.appendTextToEditorRealtimePayload !== undefined && object.appendTextToEditorRealtimePayload !== null)
        ? AppendTextToEditorRealtimePayloadProto.fromPartial(object.appendTextToEditorRealtimePayload)
        : undefined;
    message.strikethroughRangesPayload =
      object.strikethroughRangesPayload?.map((e) => StrikeThroughRangeProto.fromPartial(e)) || [];
    message.displayVisualAidPayload =
      (object.displayVisualAidPayload !== undefined && object.displayVisualAidPayload !== null)
        ? DisplayVisualAidPayloadProto.fromPartial(object.displayVisualAidPayload)
        : undefined;
    message.executeConversationalSequencePayload =
      (object.executeConversationalSequencePayload !== undefined &&
          object.executeConversationalSequencePayload !== null)
        ? ExecuteConversationalSequencePayloadProto.fromPartial(object.executeConversationalSequencePayload)
        : undefined;
    message.displayRemarksListPayload =
      (object.displayRemarksListPayload !== undefined && object.displayRemarksListPayload !== null)
        ? DisplayRemarksListPayloadProto.fromPartial(object.displayRemarksListPayload)
        : undefined;
    message.updateTextContentPayload =
      (object.updateTextContentPayload !== undefined && object.updateTextContentPayload !== null)
        ? UpdateTextContentPayloadProto.fromPartial(object.updateTextContentPayload)
        : undefined;
    message.replaceTextRangePayload =
      (object.replaceTextRangePayload !== undefined && object.replaceTextRangePayload !== null)
        ? ReplaceTextRangePayloadProto.fromPartial(object.replaceTextRangePayload)
        : undefined;
    return message;
  },
};

function createBaseAgentToClientUIActionRequest_ParametersEntry(): AgentToClientUIActionRequest_ParametersEntry {
  return { key: "", value: "" };
}

export const AgentToClientUIActionRequest_ParametersEntry: MessageFns<AgentToClientUIActionRequest_ParametersEntry> = {
  encode(
    message: AgentToClientUIActionRequest_ParametersEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentToClientUIActionRequest_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentToClientUIActionRequest_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentToClientUIActionRequest_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AgentToClientUIActionRequest_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AgentToClientUIActionRequest_ParametersEntry>,
  ): AgentToClientUIActionRequest_ParametersEntry {
    return AgentToClientUIActionRequest_ParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AgentToClientUIActionRequest_ParametersEntry>,
  ): AgentToClientUIActionRequest_ParametersEntry {
    const message = createBaseAgentToClientUIActionRequest_ParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseClientUIActionResponse(): ClientUIActionResponse {
  return { requestId: "", success: false, message: "" };
}

export const ClientUIActionResponse: MessageFns<ClientUIActionResponse> = {
  encode(message: ClientUIActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientUIActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientUIActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientUIActionResponse {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ClientUIActionResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<ClientUIActionResponse>): ClientUIActionResponse {
    return ClientUIActionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClientUIActionResponse>): ClientUIActionResponse {
    const message = createBaseClientUIActionResponse();
    message.requestId = object.requestId ?? "";
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

/** Service the agent will implement (called by frontend) */
export interface AgentInteraction {
  InvokeAgentTask(request: InvokeAgentTaskRequest): Observable<AgentResponse>;
  RequestInterrupt(request: Empty1): Promise<AgentResponse>;
  TestPing(request: Empty1): Promise<AgentResponse>;
  UpdateAgentContext(request: UpdateAgentContextRequest): Promise<AgentResponse>;
  HandleFrontendButton(request: RpcInvocationData): Promise<StringValue>;
  NotifyPageLoad(request: NotifyPageLoadRequest): Promise<AgentResponse>;
  NotifyPageLoadV2(request: RpcInvocationData): Promise<StringValue>;
  HandlePushToTalk(request: RpcInvocationData): Promise<StringValue>;
}

export const AgentInteractionServiceName = "rox.interaction.AgentInteraction";
export class AgentInteractionClientImpl implements AgentInteraction {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AgentInteractionServiceName;
    this.rpc = rpc;
    this.InvokeAgentTask = this.InvokeAgentTask.bind(this);
    this.RequestInterrupt = this.RequestInterrupt.bind(this);
    this.TestPing = this.TestPing.bind(this);
    this.UpdateAgentContext = this.UpdateAgentContext.bind(this);
    this.HandleFrontendButton = this.HandleFrontendButton.bind(this);
    this.NotifyPageLoad = this.NotifyPageLoad.bind(this);
    this.NotifyPageLoadV2 = this.NotifyPageLoadV2.bind(this);
    this.HandlePushToTalk = this.HandlePushToTalk.bind(this);
  }
  InvokeAgentTask(request: InvokeAgentTaskRequest): Observable<AgentResponse> {
    const data = InvokeAgentTaskRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "InvokeAgentTask", data);
    return result.pipe(map((data) => AgentResponse.decode(new BinaryReader(data))));
  }

  RequestInterrupt(request: Empty1): Promise<AgentResponse> {
    const data = Empty1.encode(request).finish();
    const promise = this.rpc.request(this.service, "RequestInterrupt", data);
    return promise.then((data) => AgentResponse.decode(new BinaryReader(data)));
  }

  TestPing(request: Empty1): Promise<AgentResponse> {
    const data = Empty1.encode(request).finish();
    const promise = this.rpc.request(this.service, "TestPing", data);
    return promise.then((data) => AgentResponse.decode(new BinaryReader(data)));
  }

  UpdateAgentContext(request: UpdateAgentContextRequest): Promise<AgentResponse> {
    const data = UpdateAgentContextRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateAgentContext", data);
    return promise.then((data) => AgentResponse.decode(new BinaryReader(data)));
  }

  HandleFrontendButton(request: RpcInvocationData): Promise<StringValue> {
    const data = RpcInvocationData.encode(request).finish();
    const promise = this.rpc.request(this.service, "HandleFrontendButton", data);
    return promise.then((data) => StringValue.decode(new BinaryReader(data)));
  }

  NotifyPageLoad(request: NotifyPageLoadRequest): Promise<AgentResponse> {
    const data = NotifyPageLoadRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NotifyPageLoad", data);
    return promise.then((data) => AgentResponse.decode(new BinaryReader(data)));
  }

  NotifyPageLoadV2(request: RpcInvocationData): Promise<StringValue> {
    const data = RpcInvocationData.encode(request).finish();
    const promise = this.rpc.request(this.service, "NotifyPageLoadV2", data);
    return promise.then((data) => StringValue.decode(new BinaryReader(data)));
  }

  HandlePushToTalk(request: RpcInvocationData): Promise<StringValue> {
    const data = RpcInvocationData.encode(request).finish();
    const promise = this.rpc.request(this.service, "HandlePushToTalk", data);
    return promise.then((data) => StringValue.decode(new BinaryReader(data)));
  }
}

/** Service the CLIENT will implement, and the AGENT will call */
export interface ClientSideUI {
  PerformUIAction(request: AgentToClientUIActionRequest): Promise<ClientUIActionResponse>;
}

export const ClientSideUIServiceName = "rox.interaction.ClientSideUI";
export class ClientSideUIClientImpl implements ClientSideUI {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ClientSideUIServiceName;
    this.rpc = rpc;
    this.PerformUIAction = this.PerformUIAction.bind(this);
  }
  PerformUIAction(request: AgentToClientUIActionRequest): Promise<ClientUIActionResponse> {
    const data = AgentToClientUIActionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PerformUIAction", data);
    return promise.then((data) => ClientUIActionResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
